;################################################################################################
;Name: Nicholas Flanders				Program:    @filesorta			Due: 9/9/15
;Contract:			Course:     CSCI 220			Prof:	John Broere
;
;Description: Performs calculations read in from a file, and then outputs the result to a file
;
;
;################################################################################################

;(trace @find @set @addVar @eval @second @third @if @fourth @ + - * /) ; remove comment to use trace

(setf varList NIL)
(setf tempVarList NIL)

;*************************************************************************************
; @filesorta | The basic loop that receives input from a file, and then prints out to
;	another file the results of that input.
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;
;Special Thanks to:
;
;
;Pre: A file "test.in" exists, in the current directory, with valid test data.
;Post: Input line printed to the file "test.out", value generated by (@eval now)
;	printed to that file; "quit" has been read from input file.
;`````````````````````````````````````````````````````````````````````````````````````
(defun @filesorta (&optional (fileNameIN "test.in") (fileNameOUT "test.out"))
	
	(setq fp_in (open fileNameIN :direction :input))
	(setq fp_out (open fileNameOUT :direction :output))

	(cond
		((equal fp_in NIL)  (return 'open_input_failed))
		((equal fp_out NIL) (return 'open_output_failed))
	)
	
	(princ "[" fp_out)
	(princ fileNameOUT fp_out)
	(princ "] was created using [" fp_out)
	(princ fileNameIN fp_out)
	(princ "]\n\n" fp_out)
	
	(loop
		(setf now (read fp_in))
		(print now fp_out)

		(cond
			((equal now 'quit)  	(close fp_in) (close fp_out) (return 'DONE))
			(T						(print (@eval now) fp_out))	
		)
		
		(princ "\n" fp_out)
	)
	
	(exit)
)

;*************************************************************************************
;@eval | takes in a list and determines what should be done with it, based on the first element
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
;
;pre:	a list has been provided to the function
;post:	the other parameters have been passed to the function corresponding to the first element of the provided list
;`````````````````````````````````````````````````````````````````````````````````````
(defun @eval (theList)
	(cond
		((numberp theList)         theList)
		((atom theList) (@find theList varList))
		((equal '+ (first theList))     (+ (@eval(@second theList)) (@eval(@third theList))))
		((equal '- (first theList))     (- (@eval(@second theList)) (@eval(@third theList))))
		((equal '* (first theList))     (* (@eval(@second theList)) (@eval(@third theList))))
		((equal '/ (first theList))     (/ (@eval(@second theList)) (@eval(@third theList))))
		((equal '< (first theList))     (< (@eval(@second theList)) (@eval(@third theList))))
		((equal '> (first theList))     (< (@evalThird theList) (@eval(@second theList))))
		((equal '== (first theList))    (= (@eval(@second theList)) (@evalThird theList)))
		((equal '<= (first theList))    (@lessthanequal (@eval (@second theList)) (@evalThird theList)))
		((equal '>= (first theList))    (@lessthanequal (@evalThird theList) (@eval (@second theList))))
		((equal 'set (first theList))      (@set (@second theList) (@eval (@third theList))))
		((equal 'if (first theList))     (@if (@second theList) (@third theList) (@fourth theList)))
		((equal 'while (first theList))   (@while (@second theList) (@third theList)))
		((equal '^ (first theList))     (@power (@eval(@second theList)) (@eval(@third theList)))) ; exponent
		((equal '% (first theList))     (@eval(@percent theList)))                                ; percent (% <expression(init price)> <expression(discount percent)>)
		;((equal '@line (first theList))     (@line (@eval(@second theList)) (@eval(@third theList)))) ; line calc (= <expression(slope)> <expression(y-intercept)>)
		;((equal '& (first theList))     (* (@eval(@second theList)) (@eval(@second theList)))) ;square a number    ;removed because only takes one input
		;((equal '@add (first theList))  (@addVar (@second theList) (@evalThird theList)))		; for testing purposes
		;((equal '@find (first theList))     (@find (@second theList) (@third theList)))		; for testing purposes
	)
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;@second  -  simply finds the second element within a list and returns it
;
;
;pre:  a list has been provided
;post: the second element of the list has been returned
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun @second (aList)
	(first (rest aList))
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;@third  -  simply finds the third element within a list and returns it
;
;
;pre:  a list has been provided
;post: the third element of the list has been returned
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun @third (aList)
	(first(rest(rest aList)))
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;@fourth  -  simply finds the fourth element within a list and returns it
;
;
;pre:  a list has been provided
;post: the fourth element of the list has been returned
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun @fourth (aList)
	(first (rest (rest (rest aList))))
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;@evalSecond  -  combines the functionality of the @eval and @second functions
;					
;
;pre:  a list has been provided
;post: the second element of the list has been evaluated and returned
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun @evalSecond (alist)
	(@eval (@second alist))
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;@evalThird  -  combines the functionality of the @eval and @third functions
;					
;
;pre:  a list has been provided
;post: the third element of the list has been evaluated and returned
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun @evalThird (alist)
	(@eval (@third alist))
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;@find  -  returns the value of a variable from the provided variable list
;
;
;pre:  a variable name and variable list has been provided
;post: the value of the requested variable has been returned. 
;		if the variable was not found, nil is returned
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun @find (varName tVarList)
	(cond
		((equal tVarList nil)   nil)		; base case
		
		((equal varName (first (first tVarList)))  
							(first (rest (first tVarList)))) 		; returns the value of the variable if found
							
		(t         
							(@find varName (rest tVarList)))		; recursively keeps calling the find function with a smaller set of the variable list
	)
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;@addVar  -  adds a variable with an associated value into the variables list.
;
;
;pre:  a variable name and associated value has been provided
;post: the variable name and value pair has been added to the variable list
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun @addVar (varName val)
	(setf varList (cons (cons varName (cons val nil)) varList))
	; creates a list with just the value, then adds the name to it, then adds it to the variable list
 )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;@remove  -  removes a variable with its associated value from the variables list.
;
;
;pre:  a variable name and a variable list has been provided
;post: the variable name and value pair has been removed from the variable list
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun @remove (varName tVarList)
	(cond 
		((equal (first (first tVarList)) varName)         ; checks the first entry for the variable
										(setf varList (@append tempVarList (rest tVarList))) ; if found moves the contents of the secondary list to the main variable list
											(setf tempVarList NIL))	; sets the secondary variable list to nil
													
		(T              (setf tempVarList (cons (first tVarList) tempVarList)) ; moves the first entry of the variable list into the secondary list
																			   ; because it's not the one we were looking for
							(@remove varName (rest tVarList))				   ; recursively keeps calling itself until the variable is found
		)
	)
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;@append  -  adds all of the variable name/value pairs from one variable list into another
;
;Special Thanks to: Nicole for the idea and guidance
;
;pre:  a source variable list and a target variable list has been provided
;post: all of the variables from the source list have been moved to the target variable list
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun @append (fromList toList) 
	(cond
		((equal fromList nil)   ; base case - once the source list is empty,
				toList) 		; return the target list
		
		(t   	
				(setf toList (cons (first fromList) toList)) ; move the first entry of the source list into the target list
				(@append (rest fromList) toList))	; recursively call itself with a reduced source list set
	) 
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;@set  -  adds a variable with an associated value into the variables list. 
;			replaces a variable name/value pair in the list if one already exists under the same
;			variable name
;
;
;pre:  a variable name and associated value has been provided
;post: the variable name and value pair has been added to the variable list
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun @set (varName val)
	(cond 
		((equal (@find varName varList) nil)    ; if the find function returns nil
						(@addVar varName val))	; the add function will be called
						
		(t     		(@remove varName varList) 	; otherwise, the remove function will eliminate the variable from the list
						(@addVar varName val))	; and then add in the new value for the variable
	)
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;@if  -  creates an if statement, which makes a decision of which operation to do,
;			depending on a condition statement
;
;
;pre:  a condition and two expressions have been provided
;post: if the condition has evaluated to true, the first expression has been executed
;		otherwise the second expression has been executed
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun @if (condition exprone exprtwo)
	(cond
		((equal (@eval condition) t)		; if the condition evaluates to true
						(@eval exprone))	; the first expression will be executed
						
		(t        (@eval exprtwo))			; else, the second expression will be executed
	)
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;@while  -  creates an looping action that can be stopped if the condition statement evaluates 
;				to false
;
;
;pre:  a condition and an expression has been provided
;post: the expression has been executed until the condition has evaluated to false
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun @while (condition expr)
	(cond
		((equal (@eval condition) t) 		; if the condition evaluates to true, 
							(@eval expr) (@while condition expr)) ; the expression will be executed and the function is recursively called
						
		(t     (princ "done"))				; once the condition evaluates to false, "done" will be printed
	)
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;@lessthanequal  -  compares two expressions, returns true if the first expression is less than
;						or equal to the second expression
;
;
;pre:  two expressions have been provided
;post: true has been returned if expression one has evaluated to less than or equal to the 2nd
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun @lessthanequal (exprone exprtwo)
	(cond
		((< exprone exprtwo)       t)	; if expression one is less than expression two, true is returned
		((= exprone exprtwo)       t)	; if expression one is equal to expression two, true is returned
		(t    nil)						; else, nil is returned
	)
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;@percent calculates the new price of a discounted item
;
;
;pre:   a list has been provided. (% <initial number> <percent off (0-100)>)
;post:  the answer has been returned
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun @percent (aList)
	(* (@eval(@second aList)) (/ (@eval(@third aList)) 100))
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;@power calculates and returns the result of x^y
;			resursively calls itself, until exponent reaches 0
;
;pre:   two numbers have been passed into the function, a base and an exponent
;post:  the value of result has been returned
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun @power (base expo)
	(cond
		((equal expo 0) 1)  ;break case
		(t                      (* base (@power base (- expo 1))))
	)
)

;(@filesorta)
; This is how you would specify a different file name
;(@filesorta 'simple.in 'simple.out)
